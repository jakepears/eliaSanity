{
  "version": 3,
  "sources": ["../node_modules/jsonwebtoken/verify.js", "../src/verify.js"],
  "sourcesContent": ["var JsonWebTokenError = require('./lib/JsonWebTokenError');\nvar NotBeforeError    = require('./lib/NotBeforeError');\nvar TokenExpiredError = require('./lib/TokenExpiredError');\nvar decode            = require('./decode');\nvar timespan          = require('./lib/timespan');\nvar PS_SUPPORTED      = require('./lib/psSupported');\nvar jws               = require('jws');\n\nvar PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512'];\nvar RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];\nvar HS_ALGS = ['HS256', 'HS384', 'HS512'];\n\nif (PS_SUPPORTED) {\n  PUB_KEY_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');\n  RSA_KEY_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');\n}\n\nmodule.exports = function (jwtString, secretOrPublicKey, options, callback) {\n  if ((typeof options === 'function') && !callback) {\n    callback = options;\n    options = {};\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  //clone this object since we are going to mutate it.\n  options = Object.assign({}, options);\n\n  var done;\n\n  if (callback) {\n    done = callback;\n  } else {\n    done = function(err, data) {\n      if (err) throw err;\n      return data;\n    };\n  }\n\n  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {\n    return done(new JsonWebTokenError('clockTimestamp must be a number'));\n  }\n\n  if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {\n    return done(new JsonWebTokenError('nonce must be a non-empty string'));\n  }\n\n  var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);\n\n  if (!jwtString){\n    return done(new JsonWebTokenError('jwt must be provided'));\n  }\n\n  if (typeof jwtString !== 'string') {\n    return done(new JsonWebTokenError('jwt must be a string'));\n  }\n\n  var parts = jwtString.split('.');\n\n  if (parts.length !== 3){\n    return done(new JsonWebTokenError('jwt malformed'));\n  }\n\n  var decodedToken;\n\n  try {\n    decodedToken = decode(jwtString, { complete: true });\n  } catch(err) {\n    return done(err);\n  }\n\n  if (!decodedToken) {\n    return done(new JsonWebTokenError('invalid token'));\n  }\n\n  var header = decodedToken.header;\n  var getSecret;\n\n  if(typeof secretOrPublicKey === 'function') {\n    if(!callback) {\n      return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));\n    }\n\n    getSecret = secretOrPublicKey;\n  }\n  else {\n    getSecret = function(header, secretCallback) {\n      return secretCallback(null, secretOrPublicKey);\n    };\n  }\n\n  return getSecret(header, function(err, secretOrPublicKey) {\n    if(err) {\n      return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));\n    }\n\n    var hasSignature = parts[2].trim() !== '';\n\n    if (!hasSignature && secretOrPublicKey){\n      return done(new JsonWebTokenError('jwt signature is required'));\n    }\n\n    if (hasSignature && !secretOrPublicKey) {\n      return done(new JsonWebTokenError('secret or public key must be provided'));\n    }\n\n    if (!hasSignature && !options.algorithms) {\n      options.algorithms = ['none'];\n    }\n\n    if (!options.algorithms) {\n      options.algorithms = ~secretOrPublicKey.toString().indexOf('BEGIN CERTIFICATE') ||\n        ~secretOrPublicKey.toString().indexOf('BEGIN PUBLIC KEY') ? PUB_KEY_ALGS :\n        ~secretOrPublicKey.toString().indexOf('BEGIN RSA PUBLIC KEY') ? RSA_KEY_ALGS : HS_ALGS;\n\n    }\n\n    if (!~options.algorithms.indexOf(decodedToken.header.alg)) {\n      return done(new JsonWebTokenError('invalid algorithm'));\n    }\n\n    var valid;\n\n    try {\n      valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);\n    } catch (e) {\n      return done(e);\n    }\n\n    if (!valid) {\n      return done(new JsonWebTokenError('invalid signature'));\n    }\n\n    var payload = decodedToken.payload;\n\n    if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {\n      if (typeof payload.nbf !== 'number') {\n        return done(new JsonWebTokenError('invalid nbf value'));\n      }\n      if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {\n        return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));\n      }\n    }\n\n    if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {\n      if (typeof payload.exp !== 'number') {\n        return done(new JsonWebTokenError('invalid exp value'));\n      }\n      if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));\n      }\n    }\n\n    if (options.audience) {\n      var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];\n      var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];\n\n      var match = target.some(function (targetAudience) {\n        return audiences.some(function (audience) {\n          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;\n        });\n      });\n\n      if (!match) {\n        return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));\n      }\n    }\n\n    if (options.issuer) {\n      var invalid_issuer =\n              (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||\n              (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);\n\n      if (invalid_issuer) {\n        return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));\n      }\n    }\n\n    if (options.subject) {\n      if (payload.sub !== options.subject) {\n        return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));\n      }\n    }\n\n    if (options.jwtid) {\n      if (payload.jti !== options.jwtid) {\n        return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));\n      }\n    }\n\n    if (options.nonce) {\n      if (payload.nonce !== options.nonce) {\n        return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));\n      }\n    }\n\n    if (options.maxAge) {\n      if (typeof payload.iat !== 'number') {\n        return done(new JsonWebTokenError('iat required when maxAge is specified'));\n      }\n\n      var maxAgeTimestamp = timespan(options.maxAge, payload.iat);\n      if (typeof maxAgeTimestamp === 'undefined') {\n        return done(new JsonWebTokenError('\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n      }\n      if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));\n      }\n    }\n\n    if (options.complete === true) {\n      var signature = decodedToken.signature;\n\n      return done(null, {\n        header: header,\n        payload: payload,\n        signature: signature\n      });\n    }\n\n    return done(null, payload);\n  });\n};\n", "export { default } from 'jsonwebtoken/verify'\n"],
  "mappings": "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",
  "names": ["require_verify", "__commonJSMin", "exports", "module", "init_virtual_process_polyfill", "init_buffer", "JsonWebTokenError", "NotBeforeError", "TokenExpiredError", "decode", "timespan", "PS_SUPPORTED", "jws", "PUB_KEY_ALGS", "RSA_KEY_ALGS", "HS_ALGS", "jwtString", "secretOrPublicKey", "options", "callback", "done", "err", "data", "clockTimestamp", "parts", "decodedToken", "header", "getSecret", "secretCallback", "hasSignature", "valid", "e", "payload", "audiences", "target", "match", "targetAudience", "audience", "invalid_issuer", "maxAgeTimestamp", "signature", "init_virtual_process_polyfill", "init_buffer", "import_verify"]
}
